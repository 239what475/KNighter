Your plan for the UndefinedArraySubscriptChecker is as follows:

1. Register the Checker on ArraySubscriptExpr Nodes  
   • The checker is registered to run on every ArraySubscriptExpr before it is evaluated (using the check::PreStmt callback).  
   • This ensures we can check the subscript expression (the array index) before it is used.

2. Retrieve and Check the Array Index’s Value  
   • In the checkPreStmt callback, start by getting the index expression with A->getIdx().  
   • Use the CheckerContext to obtain the symbolic value (SVal) of the index.  
   • Check whether the SVal is undefined by calling isUndef().  
   • If the index is not undefined, return immediately because there’s no problem.

3. Avoid False Positives in Implicitly-Generated Code  
   • Retrieve the current declaration context (using C.getLocationContext()->getDecl()).  
   • If the context is a defaulted C++ constructor (which Sema may generate for copying array struct fields), then skip issuing a warning.  
   • This filtering prevents false reports on code generated by the compiler.

4. Generate an Error Node and Prepare the Bug Report  
   • If the index SVal is undefined and we are not in an implicitly-generated constructor, generate an exploded error node (using C.generateErrorNode()).  
   • If no error node is generated (e.g., if this path was already analyzed), then simply return.  
   • Create a bug report (PathSensitiveBugReport) with the pre-defined BugType and a message like “Array subscript is undefined”.  
   • Add the source range of the index expression to the diagnostic report to highlight the problem.

5. Track the Expression Value and Emit the Report  
   • Use bugreporter::trackExpressionValue to attach additional information about the evaluated index expression.  
   • Finally, emit the bug report (via C.emitReport) so that the analyzer outputs the warning.

Each step is designed to be as straightforward as possible while ensuring that the checker only issues a warning when an array subscript is truly undefined and not just a side effect of implicitly-generated support code.